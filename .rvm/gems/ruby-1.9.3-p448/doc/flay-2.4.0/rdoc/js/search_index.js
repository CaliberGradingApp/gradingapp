var search_data = {"index":{"searchIndex":["file","flay","flaygauntlet","flaytask","sexp","string","all_structural_subhashes()","analyze()","code_index()","default_options()","define()","expand_dirs_to_files()","has_code?()","load_plugins()","n_way_diff()","new()","new()","parse_options()","process()","process_erb()","process_fuzzy()","process_rb()","process_sexp()","prune()","prune_conservatively()","prune_liberally()","report()","sexp_to_rb()","split_at()","split_code()","structural_hash()","summary()","update_masses()","history","manifest","readme"],"longSearchIndex":["file","flay","flaygauntlet","flaytask","sexp","string","sexp#all_structural_subhashes()","flay#analyze()","sexp#code_index()","flay::default_options()","flaytask#define()","flay::expand_dirs_to_files()","sexp#has_code?()","flay::load_plugins()","flay#n_way_diff()","flay::new()","flaytask::new()","flay::parse_options()","flay#process()","flay#process_erb()","flay#process_fuzzy()","flay#process_rb()","flay#process_sexp()","flay#prune()","flay#prune_conservatively()","flay#prune_liberally()","flay#report()","flay#sexp_to_rb()","sexp#split_at()","sexp#split_code()","sexp#structural_hash()","flay#summary()","flay#update_masses()","","",""],"info":[["File","","File.html","",""],["Flay","","Flay.html","",""],["FlayGauntlet","","FlayGauntlet.html","",""],["FlayTask","","FlayTask.html","",""],["Sexp","","Sexp.html","",""],["String","","String.html","",""],["all_structural_subhashes","Sexp","Sexp.html#method-i-all_structural_subhashes","()","<p>Returns a list of structural hashes for all nodes (and sub-nodes) of this\nsexp.\n"],["analyze","Flay","Flay.html#method-i-analyze","()","<p>Prune, find identical nodes, and update masses.\n"],["code_index","Sexp","Sexp.html#method-i-code_index","()","<p>Return the index of the last non-code element, or nil if this sexp is not a\ncode-bearing node.\n"],["default_options","Flay","Flay.html#method-c-default_options","()","<p>Returns the default options.\n"],["define","FlayTask","FlayTask.html#method-i-define","()","<p>Defines the flay task.\n"],["expand_dirs_to_files","Flay","Flay.html#method-c-expand_dirs_to_files","(*dirs)","<p>Expands +*dirs+ to all files within that match ruby and rake extensions. –\nREFACTOR: from flog\n"],["has_code?","Sexp","Sexp.html#method-i-has_code-3F","()",""],["load_plugins","Flay","Flay.html#method-c-load_plugins","()","<p>Loads all flay plugins. Files must be named “flog_*.rb”.\n"],["n_way_diff","Flay","Flay.html#method-i-n_way_diff","(*data)","<p>Output an n-way diff from <code>data</code>. This is only used if –diff is\ngiven.\n"],["new","Flay","Flay.html#method-c-new","(option = nil)","<p>Create a new instance of Flay with +option+s.\n"],["new","FlayTask","FlayTask.html#method-c-new","(name = :flay, threshold = 200, dirs = nil)","<p>Creates a new FlayTask instance with given <code>name</code>,\n<code>threshold</code>, and <code>dirs</code>.\n"],["parse_options","Flay","Flay.html#method-c-parse_options","(args = ARGV)","<p>Process options in <code>args</code>, defaulting to <code>ARGV</code>.\n"],["process","Flay","Flay.html#method-i-process","(*files)","<p>Process any number of files.\n"],["process_erb","Flay","Flay.html#method-i-process_erb","(file)","<p>Process erb and parse the result. Returns the sexp of the parsed ruby.\n"],["process_fuzzy","Flay","Flay.html#method-i-process_fuzzy","(node, difference)","<p>Process “fuzzy” matches for <code>node</code>. A fuzzy match is a subset of\n<code>node</code> up to <code>difference</code> elements …\n"],["process_rb","Flay","Flay.html#method-i-process_rb","(file)","<p>Parse a ruby <code>file</code> and return the sexp.\n<p>– TODO: change the system and rename this to parse_rb.\n"],["process_sexp","Flay","Flay.html#method-i-process_sexp","(pt)","<p>Process a sexp <code>pt</code>.\n"],["prune","Flay","Flay.html#method-i-prune","()","<p>Prunes nodes that aren’t relevant to analysis or are already covered by\nanother node.\n"],["prune_conservatively","Flay","Flay.html#method-i-prune_conservatively","()","<p>Conservative prune. Remove any bucket that is known to contain a subnode\nelement of a node in another …\n"],["prune_liberally","Flay","Flay.html#method-i-prune_liberally","()","<p>Liberal prune. Remove any <em>element</em> from a bucket that is known to\nbe a subnode of another node. Removed …\n"],["report","Flay","Flay.html#method-i-report","(prune = nil)","<p>Output the report. Duh.\n"],["sexp_to_rb","Flay","Flay.html#method-i-sexp_to_rb","(sexp)",""],["split_at","Sexp","Sexp.html#method-i-split_at","(n)","<p>Useful general array method that splits the array from 0..<code>n</code>\nand the rest. Returns both sections.\n"],["split_code","Sexp","Sexp.html#method-i-split_code","()","<p>Split the sexp into front-matter and code-matter, returning both. See\n#code_index.\n"],["structural_hash","Sexp","Sexp.html#method-i-structural_hash","()","<p>Calculate the structural hash for this sexp. Cached, so don’t modify the\nsexp afterwards and expect it …\n"],["summary","Flay","Flay.html#method-i-summary","()","<p>Calculate summary scores on a per-file basis. For –summary.\n"],["update_masses","Flay","Flay.html#method-i-update_masses","()","<p>Reset total and recalculate the masses for all nodes in\n<code>hashes</code>.\n"],["History","","History_txt.html","","<p>2.4.0 / 2013-07-24\n<p>1 minor enhancement:\n<p>Allow plugins to provide sexp to source converters for –diff. …\n"],["Manifest","","Manifest_txt.html","","<p>History.txt Manifest.txt README.txt Rakefile bin/flay lib/flay.rb\nlib/flay_erb.rb lib/flay_task.rb lib/gauntlet_flay.rb …\n"],["README","","README_txt.html","","<p>flay\n<p>home  &mdash; ruby.sadi.st/\n<p>code  &mdash; github.com/seattlerb/flay\n"]]}}