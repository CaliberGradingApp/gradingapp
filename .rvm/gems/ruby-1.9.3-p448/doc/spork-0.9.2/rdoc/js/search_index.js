var search_data = {"index":{"searchIndex":["magazineslave","spork","appframework","padrino","rails","unknown","customiostreams","classmethods","diagnoser","forker","forkdiedexception","gemhelpers","gempath","runstrategy","forking","magazine","runner","server","testframework","cucumber","factoryexception","frameworknotavailable","noframeworkmatched","noframeworksavailable","rspec","sporkdebugger","eachrunstate","networkhelpers","preloadstate","<=>()","[]()","abort()","abort()","abort()","abort()","abort()","add_included_file()","after_each_run()","application_file()","assert_ready!()","assert_ready!()","assert_ready!()","available?()","available?()","available?()","available_test_frameworks()","boot_contents()","boot_file()","boot_file()","bootstrap()","bootstrap_required?()","bootstrapped?()","cleanup()","connect_rdebug_client()","debugger()","default_port()","default_port()","deprecated_version()","detect_and_require()","detect_framework()","detect_framework_name()","each_run()","eager_load!()","entry_point()","entry_point()","entry_point()","entry_point()","entry_point()","environment_contents()","environment_file()","exec_after_each_run()","exec_each_run()","exec_prefork()","factory()","factory()","fill_slave_pool()","find_port()","find_test_framework()","finish()","framework()","helper()","helper_file()","helper_file()","included()","inherited()","inherited()","install_hook()","install_hook!()","instances()","kill_all_processes()","kill_slave()","latest_load_paths()","listen()","listen_for_connection_signals()","load()","load_preference_index()","loaded_files()","main_loop()","message()","message()","message()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","other_spork_gem_load_paths()","output_results()","prefork()","preload()","preload()","preload()","preload()","preload()","preload()","preload()","preload()","preload()","preload_rails()","prepare_debugger()","remove_hook!()","require()","restart_slave()","result()","rspec1?()","run()","run()","run()","run()","run()","run()","run()","run()","run()","run_tests()","run_tests()","run_tests()","running?()","running?()","running?()","running?()","setup_autoload()","short_name()","short_name()","short_name()","short_name()","signal_spork_server_to_connect_to_rdebug_server()","slave_count()","slave_max()","spawn_process()","start_rinda_ringserver()","start_rdebug_server()","start_slave()","state()","stderr()","stderr()","stdout()","stdout()","supported_test_frameworks()","supported_test_frameworks_text()","transition_to_each_run_state()","trap_class_method()","trap_method()","using_spork?()","vendor()","wait_for_connection()","windows?()","mit-license","readme"],"longSearchIndex":["magazineslave","spork","spork::appframework","spork::appframework::padrino","spork::appframework::rails","spork::appframework::unknown","spork::customiostreams","spork::customiostreams::classmethods","spork::diagnoser","spork::forker","spork::forker::forkdiedexception","spork::gemhelpers","spork::gemhelpers::gempath","spork::runstrategy","spork::runstrategy::forking","spork::runstrategy::magazine","spork::runner","spork::server","spork::testframework","spork::testframework::cucumber","spork::testframework::factoryexception","spork::testframework::frameworknotavailable","spork::testframework::noframeworkmatched","spork::testframework::noframeworksavailable","spork::testframework::rspec","sporkdebugger","sporkdebugger::eachrunstate","sporkdebugger::networkhelpers","sporkdebugger::preloadstate","spork::gemhelpers::gempath#<=>()","spork::appframework::[]()","spork::forker#abort()","spork::runstrategy#abort()","spork::runstrategy::forking#abort()","spork::runstrategy::magazine#abort()","spork::server#abort()","spork::diagnoser::add_included_file()","spork::after_each_run()","spork::appframework::rails#application_file()","spork::runstrategy#assert_ready!()","spork::runstrategy::forking#assert_ready!()","spork::runstrategy::magazine#assert_ready!()","spork::runstrategy::forking::available?()","spork::runstrategy::magazine::available?()","spork::testframework::available?()","spork::testframework::available_test_frameworks()","spork::appframework::padrino#boot_contents()","spork::appframework::padrino#boot_file()","spork::appframework::rails#boot_file()","spork::testframework#bootstrap()","spork::appframework#bootstrap_required?()","spork::testframework#bootstrapped?()","spork::runstrategy#cleanup()","sporkdebugger::preloadstate#connect_rdebug_client()","sporkdebugger::preloadstate#debugger()","spork::testframework::default_port()","spork::testframework#default_port()","spork::appframework::rails#deprecated_version()","spork::detect_and_require()","spork::appframework::detect_framework()","spork::appframework::detect_framework_name()","spork::each_run()","spork::appframework::rails#eager_load!()","spork::appframework#entry_point()","spork::appframework::padrino#entry_point()","spork::appframework::rails#entry_point()","spork::appframework::unknown#entry_point()","spork::testframework#entry_point()","spork::appframework::rails#environment_contents()","spork::appframework::rails#environment_file()","spork::exec_after_each_run()","spork::exec_each_run()","spork::exec_prefork()","spork::runstrategy::factory()","spork::testframework::factory()","spork::runstrategy::magazine#fill_slave_pool()","sporkdebugger::networkhelpers#find_port()","spork::runner#find_test_framework()","sporkdebugger::preloadstate#finish()","spork::testframework#framework()","spork::appframework::rails#helper()","spork::testframework::helper_file()","spork::testframework#helper_file()","spork::customiostreams::included()","spork::runstrategy::inherited()","spork::testframework::inherited()","sporkdebugger::preloadstate#install_hook()","spork::diagnoser::install_hook!()","spork::appframework::instances()","spork::runstrategy::magazine#kill_all_processes()","spork::runstrategy::magazine#kill_slave()","spork::gemhelpers#latest_load_paths()","spork::server#listen()","sporkdebugger::preloadstate#listen_for_connection_signals()","spork::diagnoser::load()","spork::testframework::load_preference_index()","spork::diagnoser::loaded_files()","sporkdebugger::preloadstate#main_loop()","spork::testframework::frameworknotavailable#message()","spork::testframework::noframeworkmatched#message()","spork::testframework::noframeworksavailable#message()","magazineslave::new()","spork::forker::new()","spork::gemhelpers::gempath::new()","spork::runstrategy::new()","spork::runstrategy::magazine::new()","spork::runner::new()","spork::server::new()","spork::testframework::new()","spork::testframework::frameworknotavailable::new()","spork::testframework::noframeworkmatched::new()","sporkdebugger::new()","sporkdebugger::eachrunstate::new()","sporkdebugger::preloadstate::new()","spork::other_spork_gem_load_paths()","spork::diagnoser::output_results()","spork::prefork()","magazineslave#preload()","spork::appframework#preload()","spork::appframework::padrino#preload()","spork::appframework::rails#preload()","spork::runstrategy#preload()","spork::runstrategy::forking#preload()","spork::runstrategy::magazine#preload()","spork::testframework#preload()","spork::testframework::cucumber#preload()","spork::appframework::rails#preload_rails()","sporkdebugger::eachrunstate#prepare_debugger()","spork::diagnoser::remove_hook!()","spork::diagnoser::require()","spork::runstrategy::magazine#restart_slave()","spork::forker#result()","spork::testframework::rspec#rspec1?()","magazineslave#run()","spork::runstrategy#run()","spork::runstrategy::forking#run()","spork::runstrategy::magazine#run()","spork::runner#run()","spork::runner::run()","spork::server::run()","spork::server#run()","sporkdebugger::run()","spork::testframework#run_tests()","spork::testframework::cucumber#run_tests()","spork::testframework::rspec#run_tests()","spork::forker#running?()","spork::runstrategy#running?()","spork::runstrategy::forking#running?()","spork::runstrategy::magazine#running?()","spork::appframework::setup_autoload()","spork::appframework#short_name()","spork::appframework::short_name()","spork::testframework::short_name()","spork::testframework#short_name()","sporkdebugger::eachrunstate#signal_spork_server_to_connect_to_rdebug_server()","spork::runstrategy::magazine#slave_count()","spork::runstrategy::magazine#slave_max()","spork::runstrategy::magazine#spawn_process()","spork::runstrategy::magazine#start_rinda_ringserver()","sporkdebugger::eachrunstate#start_rdebug_server()","spork::runstrategy::magazine#start_slave()","spork::state()","spork::customiostreams#stderr()","spork::customiostreams::classmethods#stderr()","spork::customiostreams#stdout()","spork::customiostreams::classmethods#stdout()","spork::testframework::supported_test_frameworks()","spork::runner#supported_test_frameworks_text()","sporkdebugger::preloadstate#transition_to_each_run_state()","spork::trap_class_method()","spork::trap_method()","spork::using_spork?()","spork::appframework::rails#vendor()","sporkdebugger::eachrunstate#wait_for_connection()","spork::runstrategy::magazine#windows?()","",""],"info":[["MagazineSlave","","MagazineSlave.html","",""],["Spork","","Spork.html","",""],["Spork::AppFramework","","Spork/AppFramework.html","",""],["Spork::AppFramework::Padrino","","Spork/AppFramework/Padrino.html","",""],["Spork::AppFramework::Rails","","Spork/AppFramework/Rails.html","",""],["Spork::AppFramework::Unknown","","Spork/AppFramework/Unknown.html","","<p>This is used if no supported appliction framework is detected\n"],["Spork::CustomIOStreams","","Spork/CustomIOStreams.html","","<p>This class is mainly used for testing. When included (and used), it gives\nus an opportunity to stub out …\n"],["Spork::CustomIOStreams::ClassMethods","","Spork/CustomIOStreams/ClassMethods.html","",""],["Spork::Diagnoser","","Spork/Diagnoser.html","","<p>The Diagnoser hooks into load and require and keeps track of when files are\nrequired / loaded, and who …\n"],["Spork::Forker","","Spork/Forker.html","","<p>A helper class that allows you to run a block inside of a fork, and then\nget the result from that block. …\n"],["Spork::Forker::ForkDiedException","","Spork/Forker/ForkDiedException.html","","<p>Raised if the fork died (was killed) before it sent it’s response back.\n"],["Spork::GemHelpers","","Spork/GemHelpers.html","",""],["Spork::GemHelpers::GemPath","","Spork/GemHelpers/GemPath.html","",""],["Spork::RunStrategy","","Spork/RunStrategy.html","",""],["Spork::RunStrategy::Forking","","Spork/RunStrategy/Forking.html","",""],["Spork::RunStrategy::Magazine","","Spork/RunStrategy/Magazine.html","",""],["Spork::Runner","","Spork/Runner.html","","<p>This is used by bin/spork. It’s wrapped in a class because it’s easier to\ntest that way.\n"],["Spork::Server","","Spork/Server.html","","<p>An abstract class that is implemented to create a server\n<p>(This was originally based off of spec_server.rb …\n"],["Spork::TestFramework","","Spork/TestFramework.html","",""],["Spork::TestFramework::Cucumber","","Spork/TestFramework/Cucumber.html","",""],["Spork::TestFramework::FactoryException","","Spork/TestFramework/FactoryException.html","",""],["Spork::TestFramework::FrameworkNotAvailable","","Spork/TestFramework/FrameworkNotAvailable.html","",""],["Spork::TestFramework::NoFrameworkMatched","","Spork/TestFramework/NoFrameworkMatched.html","",""],["Spork::TestFramework::NoFrameworksAvailable","","Spork/TestFramework/NoFrameworksAvailable.html","",""],["Spork::TestFramework::RSpec","","Spork/TestFramework/RSpec.html","",""],["SporkDebugger","","SporkDebugger.html","","<p>Experimental!\n"],["SporkDebugger::EachRunState","","SporkDebugger/EachRunState.html","",""],["SporkDebugger::NetworkHelpers","","SporkDebugger/NetworkHelpers.html","",""],["SporkDebugger::PreloadState","","SporkDebugger/PreloadState.html","",""],["<=>","Spork::GemHelpers::GemPath","Spork/GemHelpers/GemPath.html#method-i-3C-3D-3E","(other)",""],["[]","Spork::AppFramework","Spork/AppFramework.html#method-c-5B-5D","(name)","<p>Initializes, stores, and returns a singleton instance of the named\nAppFramework.\n<p>Parameters\n<p># <code>name</code> - A …\n"],["abort","Spork::Forker","Spork/Forker.html#method-i-abort","()","<p>abort the current running fork\n"],["abort","Spork::RunStrategy","Spork/RunStrategy.html#method-i-abort","()",""],["abort","Spork::RunStrategy::Forking","Spork/RunStrategy/Forking.html#method-i-abort","()",""],["abort","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-abort","()",""],["abort","Spork::Server","Spork/Server.html#method-i-abort","()",""],["add_included_file","Spork::Diagnoser","Spork/Diagnoser.html#method-c-add_included_file","(filename, callstack)",""],["after_each_run","Spork","Spork.html#method-c-after_each_run","(prevent_double_run = true, &block)","<p>Run a block after specs are run.\n<p>Parameters\n<p><code>prevent_double_run</code> - Pass false to disable double run\nprevention ...\n"],["application_file","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-application_file","()",""],["assert_ready!","Spork::RunStrategy","Spork/RunStrategy.html#method-i-assert_ready-21","()",""],["assert_ready!","Spork::RunStrategy::Forking","Spork/RunStrategy/Forking.html#method-i-assert_ready-21","()",""],["assert_ready!","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-assert_ready-21","()",""],["available?","Spork::RunStrategy::Forking","Spork/RunStrategy/Forking.html#method-c-available-3F","()",""],["available?","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-c-available-3F","()",""],["available?","Spork::TestFramework","Spork/TestFramework.html#method-c-available-3F","()","<p>Returns true if the testing frameworks helper file exists.  Override if\nthis is not sufficient to detect …\n"],["available_test_frameworks","Spork::TestFramework","Spork/TestFramework.html#method-c-available_test_frameworks","()","<p>Returns a list of all testing servers that have detected their testing\nframework being used in the project. …\n"],["boot_contents","Spork::AppFramework::Padrino","Spork/AppFramework/Padrino.html#method-i-boot_contents","()",""],["boot_file","Spork::AppFramework::Padrino","Spork/AppFramework/Padrino.html#method-i-boot_file","()",""],["boot_file","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-boot_file","()",""],["bootstrap","Spork::TestFramework","Spork/TestFramework.html#method-i-bootstrap","()","<p>Bootstraps the current test helper file by prepending a Spork.prefork and\nSpork.each_run block at the …\n"],["bootstrap_required?","Spork::AppFramework","Spork/AppFramework.html#method-i-bootstrap_required-3F","()","<p>If there is some stuff out of the box that the Spork can do to speed up\ntests without the test helper …\n"],["bootstrapped?","Spork::TestFramework","Spork/TestFramework.html#method-i-bootstrapped-3F","()","<p>Detects if the test helper has been bootstrapped.\n"],["cleanup","Spork::RunStrategy","Spork/RunStrategy.html#method-i-cleanup","()",""],["connect_rdebug_client","SporkDebugger::PreloadState","SporkDebugger/PreloadState.html#method-i-connect_rdebug_client","(port = Debugger::PORT)",""],["debugger","SporkDebugger::PreloadState","SporkDebugger/PreloadState.html#method-i-debugger","(steps = 1)",""],["default_port","Spork::TestFramework","Spork/TestFramework.html#method-c-default_port","()",""],["default_port","Spork::TestFramework","Spork/TestFramework.html#method-i-default_port","()",""],["deprecated_version","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-deprecated_version","()",""],["detect_and_require","Spork","Spork.html#method-c-detect_and_require","(subfolder)",""],["detect_framework","Spork::AppFramework","Spork/AppFramework.html#method-c-detect_framework","()","<p>Same as detect_framework_name, but returns an instance of the specific\nAppFramework class.\n"],["detect_framework_name","Spork::AppFramework","Spork/AppFramework.html#method-c-detect_framework_name","()","<p>Iterates through all SUPPORTED_FRAMEWORKS and returns the symbolic name of\nthe project application framework …\n"],["each_run","Spork","Spork.html#method-c-each_run","(prevent_double_run = true, &block)","<p>Run a block AFTER the fork occurs.  By default, if prefork is called twice\nin the same file and line …\n"],["eager_load!","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-eager_load-21","()",""],["entry_point","Spork::AppFramework","Spork/AppFramework.html#method-i-entry_point","()","<p>Abstract: The path to the file that loads the project environment, ie\nconfig/environment.rb.  Returns …\n"],["entry_point","Spork::AppFramework::Padrino","Spork/AppFramework/Padrino.html#method-i-entry_point","()",""],["entry_point","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-entry_point","()",""],["entry_point","Spork::AppFramework::Unknown","Spork/AppFramework/Unknown.html#method-i-entry_point","()",""],["entry_point","Spork::TestFramework","Spork/TestFramework.html#method-i-entry_point","()",""],["environment_contents","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-environment_contents","()",""],["environment_file","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-environment_file","()",""],["exec_after_each_run","Spork","Spork.html#method-c-exec_after_each_run","()","<p>Used by the server.  Called to run all of the after_each_run blocks.\n"],["exec_each_run","Spork","Spork.html#method-c-exec_each_run","(&block)","<p>Used by the server.  Called to run all of the prefork blocks.\n"],["exec_prefork","Spork","Spork.html#method-c-exec_prefork","(&block)","<p>Used by the server.  Called when loading the prefork blocks of the code.\n"],["factory","Spork::RunStrategy","Spork/RunStrategy.html#method-c-factory","(test_framework)",""],["factory","Spork::TestFramework","Spork/TestFramework.html#method-c-factory","(output = STDOUT, error = STDERR, beginning_with = nil)",""],["fill_slave_pool","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-fill_slave_pool","()",""],["find_port","SporkDebugger::NetworkHelpers","SporkDebugger/NetworkHelpers.html#method-i-find_port","(starting_with)",""],["find_test_framework","Spork::Runner","Spork/Runner.html#method-i-find_test_framework","()","<p>Returns a server for the specified (or the detected default) testing\nframework.  Returns nil if none …\n"],["finish","SporkDebugger::PreloadState","SporkDebugger/PreloadState.html#method-i-finish","()",""],["framework","Spork::TestFramework","Spork/TestFramework.html#method-i-framework","()",""],["helper","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-helper","(*args, &block)",""],["helper_file","Spork::TestFramework","Spork/TestFramework.html#method-c-helper_file","()",""],["helper_file","Spork::TestFramework","Spork/TestFramework.html#method-i-helper_file","()",""],["included","Spork::CustomIOStreams","Spork/CustomIOStreams.html#method-c-included","(klass)",""],["inherited","Spork::RunStrategy","Spork/RunStrategy.html#method-c-inherited","(subclass)",""],["inherited","Spork::TestFramework","Spork/TestFramework.html#method-c-inherited","(subclass)",""],["install_hook","SporkDebugger::PreloadState","SporkDebugger/PreloadState.html#method-i-install_hook","()",""],["install_hook!","Spork::Diagnoser","Spork/Diagnoser.html#method-c-install_hook-21","(entry_file = nil, dir = Dir.pwd)","<p>Installs the diagnoser hook into Kernel#require and Kernel#load\n<p>Parameters\n<p><code>entry_file</code> - The file that is ...\n"],["instances","Spork::AppFramework","Spork/AppFramework.html#method-c-instances","()",""],["kill_all_processes","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-kill_all_processes","()",""],["kill_slave","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-kill_slave","(pid)",""],["latest_load_paths","Spork::GemHelpers","Spork/GemHelpers.html#method-i-latest_load_paths","()",""],["listen","Spork::Server","Spork/Server.html#method-i-listen","()","<p>Sets up signals and starts the DRb service. If it’s successful, it doesn’t\nreturn. Not ever.  You don’t …\n"],["listen_for_connection_signals","SporkDebugger::PreloadState","SporkDebugger/PreloadState.html#method-i-listen_for_connection_signals","()",""],["load","Spork::Diagnoser","Spork/Diagnoser.html#method-c-load","(string, wrap = false)",""],["load_preference_index","Spork::TestFramework","Spork/TestFramework.html#method-c-load_preference_index","()","<p>Used to specify\n"],["loaded_files","Spork::Diagnoser","Spork/Diagnoser.html#method-c-loaded_files","()",""],["main_loop","SporkDebugger::PreloadState","SporkDebugger/PreloadState.html#method-i-main_loop","()",""],["message","Spork::TestFramework::FrameworkNotAvailable","Spork/TestFramework/FrameworkNotAvailable.html#method-i-message","()",""],["message","Spork::TestFramework::NoFrameworkMatched","Spork/TestFramework/NoFrameworkMatched.html#method-i-message","()",""],["message","Spork::TestFramework::NoFrameworksAvailable","Spork/TestFramework/NoFrameworksAvailable.html#method-i-message","()",""],["new","MagazineSlave","MagazineSlave.html#method-c-new","(id_num, test_framework_short_name)",""],["new","Spork::Forker","Spork/Forker.html#method-c-new","(&block)",""],["new","Spork::GemHelpers::GemPath","Spork/GemHelpers/GemPath.html#method-c-new","(p)",""],["new","Spork::RunStrategy","Spork/RunStrategy.html#method-c-new","(test_framework)",""],["new","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-c-new","(test_framework)",""],["new","Spork::Runner","Spork/Runner.html#method-c-new","(args, output, error)",""],["new","Spork::Server","Spork/Server.html#method-c-new","(options = {})",""],["new","Spork::TestFramework","Spork/TestFramework.html#method-c-new","(stdout = STDOUT, stderr = STDERR)",""],["new","Spork::TestFramework::FrameworkNotAvailable","Spork/TestFramework/FrameworkNotAvailable.html#method-c-new","(framework)",""],["new","Spork::TestFramework::NoFrameworkMatched","Spork/TestFramework/NoFrameworkMatched.html#method-c-new","(beginning_with)",""],["new","SporkDebugger","SporkDebugger.html#method-c-new","()",""],["new","SporkDebugger::EachRunState","SporkDebugger/EachRunState.html#method-c-new","(connection_request_port)",""],["new","SporkDebugger::PreloadState","SporkDebugger/PreloadState.html#method-c-new","()",""],["other_spork_gem_load_paths","Spork","Spork.html#method-c-other_spork_gem_load_paths","()","<p>This method is used to auto-discover peer plugins such as spork-testunit.\n"],["output_results","Spork::Diagnoser","Spork/Diagnoser.html#method-c-output_results","(stdout)","<p>output the results of a diagnostic run.\n<p>Parameters\n<p><code>stdout</code> - An IO stream to output the results to.\n"],["prefork","Spork","Spork.html#method-c-prefork","(prevent_double_run = true, &block)","<p>Run a block, during prefork mode.  By default, if prefork is called twice\nin the same file and line number, …\n"],["preload","MagazineSlave","MagazineSlave.html#method-i-preload","()",""],["preload","Spork::AppFramework","Spork/AppFramework.html#method-i-preload","(&block)",""],["preload","Spork::AppFramework::Padrino","Spork/AppFramework/Padrino.html#method-i-preload","(&block)",""],["preload","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-preload","(&block)",""],["preload","Spork::RunStrategy","Spork/RunStrategy.html#method-i-preload","()",""],["preload","Spork::RunStrategy::Forking","Spork/RunStrategy/Forking.html#method-i-preload","()",""],["preload","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-preload","()",""],["preload","Spork::TestFramework","Spork/TestFramework.html#method-i-preload","()",""],["preload","Spork::TestFramework::Cucumber","Spork/TestFramework/Cucumber.html#method-i-preload","()",""],["preload_rails","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-preload_rails","()",""],["prepare_debugger","SporkDebugger::EachRunState","SporkDebugger/EachRunState.html#method-i-prepare_debugger","()",""],["remove_hook!","Spork::Diagnoser","Spork/Diagnoser.html#method-c-remove_hook-21","()","<p>Uninstall the hook. Generally useful only for testing the Diagnoser.\n"],["require","Spork::Diagnoser","Spork/Diagnoser.html#method-c-require","(string)",""],["restart_slave","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-restart_slave","(id)",""],["result","Spork::Forker","Spork/Forker.html#method-i-result","()","<p>Wait for the fork to finish running, and then return its return value.\n<p>If the fork was aborted, then result …\n"],["rspec1?","Spork::TestFramework::RSpec","Spork/TestFramework/RSpec.html#method-i-rspec1-3F","()",""],["run","MagazineSlave","MagazineSlave.html#method-i-run","(argv, stderr, stdout)",""],["run","Spork::RunStrategy","Spork/RunStrategy.html#method-i-run","(argv, input, output)",""],["run","Spork::RunStrategy::Forking","Spork/RunStrategy/Forking.html#method-i-run","(argv, stderr, stdout)",""],["run","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-run","(argv, stderr, stdout)",""],["run","Spork::Runner","Spork/Runner.html#method-i-run","()",""],["run","Spork::Runner","Spork/Runner.html#method-c-run","(args, output, error)",""],["run","Spork::Server","Spork/Server.html#method-c-run","(options = {})",""],["run","Spork::Server","Spork/Server.html#method-i-run","(argv, stderr, stdout)","<p>This is the public facing method that is served up by DRb.  To use it from\nthe client side (in a testing …\n"],["run","SporkDebugger","SporkDebugger.html#method-c-run","()",""],["run_tests","Spork::TestFramework","Spork/TestFramework.html#method-i-run_tests","(argv, stderr, stdout)",""],["run_tests","Spork::TestFramework::Cucumber","Spork/TestFramework/Cucumber.html#method-i-run_tests","(argv, stderr, stdout)",""],["run_tests","Spork::TestFramework::RSpec","Spork/TestFramework/RSpec.html#method-i-run_tests","(argv, stderr, stdout)",""],["running?","Spork::Forker","Spork/Forker.html#method-i-running-3F","()",""],["running?","Spork::RunStrategy","Spork/RunStrategy.html#method-i-running-3F","()",""],["running?","Spork::RunStrategy::Forking","Spork/RunStrategy/Forking.html#method-i-running-3F","()",""],["running?","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-running-3F","()",""],["setup_autoload","Spork::AppFramework","Spork/AppFramework.html#method-c-setup_autoload","()",""],["short_name","Spork::AppFramework","Spork/AppFramework.html#method-i-short_name","()",""],["short_name","Spork::AppFramework","Spork/AppFramework.html#method-c-short_name","()",""],["short_name","Spork::TestFramework","Spork/TestFramework.html#method-c-short_name","()",""],["short_name","Spork::TestFramework","Spork/TestFramework.html#method-i-short_name","()",""],["signal_spork_server_to_connect_to_rdebug_server","SporkDebugger::EachRunState","SporkDebugger/EachRunState.html#method-i-signal_spork_server_to_connect_to_rdebug_server","(rdebug_server_port)",""],["slave_count","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-slave_count","()",""],["slave_max","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-slave_max","()",""],["spawn_process","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-spawn_process","(app)",""],["start_Rinda_ringserver","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-start_Rinda_ringserver","()",""],["start_rdebug_server","SporkDebugger::EachRunState","SporkDebugger/EachRunState.html#method-i-start_rdebug_server","()",""],["start_slave","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-start_slave","(id)",""],["state","Spork","Spork.html#method-c-state","()",""],["stderr","Spork::CustomIOStreams","Spork/CustomIOStreams.html#method-i-stderr","()",""],["stderr","Spork::CustomIOStreams::ClassMethods","Spork/CustomIOStreams/ClassMethods.html#method-i-stderr","()",""],["stdout","Spork::CustomIOStreams","Spork/CustomIOStreams.html#method-i-stdout","()",""],["stdout","Spork::CustomIOStreams::ClassMethods","Spork/CustomIOStreams/ClassMethods.html#method-i-stdout","()",""],["supported_test_frameworks","Spork::TestFramework","Spork/TestFramework.html#method-c-supported_test_frameworks","(starting_with = nil)","<p>Returns a list of all servers that have been implemented (it keeps track of\nthem automatically via Class.inherited …\n"],["supported_test_frameworks_text","Spork::Runner","Spork/Runner.html#method-i-supported_test_frameworks_text","()",""],["transition_to_each_run_state","SporkDebugger::PreloadState","SporkDebugger/PreloadState.html#method-i-transition_to_each_run_state","()",""],["trap_class_method","Spork","Spork.html#method-c-trap_class_method","(klass, method_name)","<p>Same as trap_method, but for class methods instead\n"],["trap_method","Spork","Spork.html#method-c-trap_method","(klass, method_name)","<p>Traps an instance method of a class (or module) so any calls to it don’t\nactually run until Spork.exec_each_run …\n"],["using_spork?","Spork","Spork.html#method-c-using_spork-3F","()",""],["vendor","Spork::AppFramework::Rails","Spork/AppFramework/Rails.html#method-i-vendor","()",""],["wait_for_connection","SporkDebugger::EachRunState","SporkDebugger/EachRunState.html#method-i-wait_for_connection","()",""],["windows?","Spork::RunStrategy::Magazine","Spork/RunStrategy/Magazine.html#method-i-windows-3F","()",""],["MIT-LICENSE","","MIT-LICENSE.html","","<p>Copyright © 2009 Tim Harper\n<p>Permission is hereby granted, free of charge, to any person obtaining a …\n"],["README","","README_rdoc.html","","<p>Spork\n<p>Repository: github.com/sporkrb/spork\n<p>Issues: github.com/sporkrb/spork/issues\n"]]}}