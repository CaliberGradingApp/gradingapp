<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class CodeRay::Scanners::Lua - coderay-1.1.0 Documentation</title>

<link type="text/css" media="screen" href="../../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../../index.html">Home</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/coderay/scanners/lua.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link">Scanner
  
</nav>

    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li><a href="#method-i-scan_tokens">#scan_tokens</a>
    
    <li><a href="#method-i-setup">#setup</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../../README_INDEX_rdoc.html">README_INDEX</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../../CodeRay.html">CodeRay</a>
  
    <li><a href="../../CodeRay/Duo.html">CodeRay::Duo</a>
  
    <li><a href="../../CodeRay/Encoders.html">CodeRay::Encoders</a>
  
    <li><a href="../../CodeRay/Encoders/CommentFilter.html">CodeRay::Encoders::CommentFilter</a>
  
    <li><a href="../../CodeRay/Encoders/Count.html">CodeRay::Encoders::Count</a>
  
    <li><a href="../../CodeRay/Encoders/Debug.html">CodeRay::Encoders::Debug</a>
  
    <li><a href="../../CodeRay/Encoders/DebugLint.html">CodeRay::Encoders::DebugLint</a>
  
    <li><a href="../../CodeRay/Encoders/Div.html">CodeRay::Encoders::Div</a>
  
    <li><a href="../../CodeRay/Encoders/Encoder.html">CodeRay::Encoders::Encoder</a>
  
    <li><a href="../../CodeRay/Encoders/Filter.html">CodeRay::Encoders::Filter</a>
  
    <li><a href="../../CodeRay/Encoders/HTML.html">CodeRay::Encoders::HTML</a>
  
    <li><a href="../../CodeRay/Encoders/HTML/Output.html">CodeRay::Encoders::HTML::Output</a>
  
    <li><a href="../../CodeRay/Encoders/JSON.html">CodeRay::Encoders::JSON</a>
  
    <li><a href="../../CodeRay/Encoders/LinesOfCode.html">CodeRay::Encoders::LinesOfCode</a>
  
    <li><a href="../../CodeRay/Encoders/Lint.html">CodeRay::Encoders::Lint</a>
  
    <li><a href="../../CodeRay/Encoders/Null.html">CodeRay::Encoders::Null</a>
  
    <li><a href="../../CodeRay/Encoders/Page.html">CodeRay::Encoders::Page</a>
  
    <li><a href="../../CodeRay/Encoders/Span.html">CodeRay::Encoders::Span</a>
  
    <li><a href="../../CodeRay/Encoders/Statistic.html">CodeRay::Encoders::Statistic</a>
  
    <li><a href="../../CodeRay/Encoders/Terminal.html">CodeRay::Encoders::Terminal</a>
  
    <li><a href="../../CodeRay/Encoders/Text.html">CodeRay::Encoders::Text</a>
  
    <li><a href="../../CodeRay/Encoders/TokenKindFilter.html">CodeRay::Encoders::TokenKindFilter</a>
  
    <li><a href="../../CodeRay/Encoders/XML.html">CodeRay::Encoders::XML</a>
  
    <li><a href="../../CodeRay/Encoders/YAML.html">CodeRay::Encoders::YAML</a>
  
    <li><a href="../../CodeRay/FileType.html">CodeRay::FileType</a>
  
    <li><a href="../../CodeRay/ForRedCloth.html">CodeRay::ForRedCloth</a>
  
    <li><a href="../../CodeRay/Plugin.html">CodeRay::Plugin</a>
  
    <li><a href="../../CodeRay/PluginHost.html">CodeRay::PluginHost</a>
  
    <li><a href="../../CodeRay/Scanners.html">CodeRay::Scanners</a>
  
    <li><a href="../../CodeRay/Scanners/C.html">CodeRay::Scanners::C</a>
  
    <li><a href="../../CodeRay/Scanners/CPlusPlus.html">CodeRay::Scanners::CPlusPlus</a>
  
    <li><a href="../../CodeRay/Scanners/CSS.html">CodeRay::Scanners::CSS</a>
  
    <li><a href="../../CodeRay/Scanners/Clojure.html">CodeRay::Scanners::Clojure</a>
  
    <li><a href="../../CodeRay/Scanners/Debug.html">CodeRay::Scanners::Debug</a>
  
    <li><a href="../../CodeRay/Scanners/Delphi.html">CodeRay::Scanners::Delphi</a>
  
    <li><a href="../../CodeRay/Scanners/Diff.html">CodeRay::Scanners::Diff</a>
  
    <li><a href="../../CodeRay/Scanners/ERB.html">CodeRay::Scanners::ERB</a>
  
    <li><a href="../../CodeRay/Scanners/Go.html">CodeRay::Scanners::Go</a>
  
    <li><a href="../../CodeRay/Scanners/Groovy.html">CodeRay::Scanners::Groovy</a>
  
    <li><a href="../../CodeRay/Scanners/HAML.html">CodeRay::Scanners::HAML</a>
  
    <li><a href="../../CodeRay/Scanners/HTML.html">CodeRay::Scanners::HTML</a>
  
    <li><a href="../../CodeRay/Scanners/JSON.html">CodeRay::Scanners::JSON</a>
  
    <li><a href="../../CodeRay/Scanners/Java.html">CodeRay::Scanners::Java</a>
  
    <li><a href="../../CodeRay/Scanners/JavaScript.html">CodeRay::Scanners::JavaScript</a>
  
    <li><a href="../../CodeRay/Scanners/Lua.html">CodeRay::Scanners::Lua</a>
  
    <li><a href="../../CodeRay/Scanners/PHP.html">CodeRay::Scanners::PHP</a>
  
    <li><a href="../../CodeRay/Scanners/Python.html">CodeRay::Scanners::Python</a>
  
    <li><a href="../../CodeRay/Scanners/Raydebug.html">CodeRay::Scanners::Raydebug</a>
  
    <li><a href="../../CodeRay/Scanners/Ruby.html">CodeRay::Scanners::Ruby</a>
  
    <li><a href="../../CodeRay/Scanners/SQL.html">CodeRay::Scanners::SQL</a>
  
    <li><a href="../../CodeRay/Scanners/Sass.html">CodeRay::Scanners::Sass</a>
  
    <li><a href="../../CodeRay/Scanners/Scanner.html">CodeRay::Scanners::Scanner</a>
  
    <li><a href="../../CodeRay/Scanners/Taskpaper.html">CodeRay::Scanners::Taskpaper</a>
  
    <li><a href="../../CodeRay/Scanners/Text.html">CodeRay::Scanners::Text</a>
  
    <li><a href="../../CodeRay/Scanners/XML.html">CodeRay::Scanners::XML</a>
  
    <li><a href="../../CodeRay/Scanners/YAML.html">CodeRay::Scanners::YAML</a>
  
    <li><a href="../../CodeRay/Styles.html">CodeRay::Styles</a>
  
    <li><a href="../../CodeRay/Styles/Alpha.html">CodeRay::Styles::Alpha</a>
  
    <li><a href="../../CodeRay/Styles/Style.html">CodeRay::Styles::Style</a>
  
    <li><a href="../../CodeRay/Tokens.html">CodeRay::Tokens</a>
  
    <li><a href="../../CodeRay/TokensProxy.html">CodeRay::TokensProxy</a>
  
    <li><a href="../../CodeRay/WordList.html">CodeRay::WordList</a>
  
    <li><a href="../../CodeRay/WordList/CaseIgnoring.html">CodeRay::WordList::CaseIgnoring</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class CodeRay::Scanners::Lua</h1>

  <div id="description" class="description">
    
<p><a href="Scanner.html">Scanner</a> for the <a href="http://lua.org">Lua</a>
programming lanuage.</p>

<p>The language’s complete syntax is defined in <a
href="http://www.lua.org/manual/5.2/manual.html">the Lua manual</a>, which
is what this scanner tries to conform to.</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="IDENT_KIND">IDENT_KIND
        
        <dd class="description"><p>Automatic token kind selection for normal words.</p>
        
      
        <dt id="KEYWORDS">KEYWORDS
        
        <dd class="description"><p>Keywords used in <a href="Lua.html">Lua</a>.</p>
        
      
        <dt id="PREDEFINED_CONSTANTS">PREDEFINED_CONSTANTS
        
        <dd class="description"><p>Constants set by the <a href="Lua.html">Lua</a> core.</p>
        
      
        <dt id="PREDEFINED_EXPRESSIONS">PREDEFINED_EXPRESSIONS
        
        <dd class="description"><p>The expressions contained in this array are parts of Lua’s `basic’ library.
Although it’s not entirely necessary to load that library, it is highly
recommended and one would have to provide own implementations of some of
these expressions if one does not do so. They however aren’t keywords,
neither are they constants, but nearly predefined, so they get tagged as
`predefined’ rather than anything else.</p>

<p>This list excludes values of form `_UPPERCASE’ because the <a
href="Lua.html">Lua</a> manual requires such identifiers to be reserved by
<a href="Lua.html">Lua</a> anyway and they are highlighted directly
accordingly, without the need for specific identifiers to be listed here.</p>
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Protected Instance Methods</h3>

    
      <div id="method-i-scan_tokens" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">scan_tokens</span><span
            class="method-args">(encoder, options)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><a href="../../CodeRay.html">CodeRay</a> entry hook. Starts parsing.</p>
          

          
          <div class="method-source-code" id="scan_tokens-source">
            <pre><span class="ruby-comment"># File lib/coderay/scanners/lua.rb, line 59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">scan_tokens</span>(<span class="ruby-identifier">encoder</span>, <span class="ruby-identifier">options</span>)
  <span class="ruby-identifier">state</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:state</span>] <span class="ruby-operator">||</span> <span class="ruby-ivar">@state</span>
  <span class="ruby-identifier">brace_depth</span> = <span class="ruby-ivar">@brace_depth</span>
  <span class="ruby-identifier">num_equals</span> = <span class="ruby-keyword">nil</span>
  
  <span class="ruby-keyword">until</span> <span class="ruby-identifier">eos?</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">state</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\-\-\[\=*\[/</span>)   <span class="ruby-comment">#--[[ long (possibly multiline) comment ]]</span>
        <span class="ruby-identifier">num_equals</span> = <span class="ruby-identifier">match</span>.<span class="ruby-identifier">count</span>(<span class="ruby-string">&quot;=&quot;</span>) <span class="ruby-comment"># Number must match for comment end</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">begin_group</span>(<span class="ruby-value">:comment</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:long_comment</span>
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/--.*$/</span>) <span class="ruby-comment"># --Lua comment</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:comment</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\[=*\[/</span>)     <span class="ruby-comment"># [[ long (possibly multiline) string ]]</span>
        <span class="ruby-identifier">num_equals</span> = <span class="ruby-identifier">match</span>.<span class="ruby-identifier">count</span>(<span class="ruby-string">&quot;=&quot;</span>) <span class="ruby-comment"># Number must match for comment end</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">begin_group</span>(<span class="ruby-value">:string</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:long_string</span>
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/::\s*[a-zA-Z_][a-zA-Z0-9_]+\s*::/</span>) <span class="ruby-comment"># ::goto_label::</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:label</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/_[A-Z]+/</span>) <span class="ruby-comment"># _UPPERCASE are names reserved for Lua</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:predefined</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]*/</span>) <span class="ruby-comment"># Normal letters (or letters followed by digits)</span>
        <span class="ruby-identifier">kind</span> = <span class="ruby-constant">IDENT_KIND</span>[<span class="ruby-identifier">match</span>]
        
        <span class="ruby-comment"># Extra highlighting for entities following certain keywords</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">kind</span> <span class="ruby-operator">==</span> <span class="ruby-value">:keyword</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">match</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;function&quot;</span>
          <span class="ruby-identifier">state</span> = <span class="ruby-value">:function_expected</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">kind</span> <span class="ruby-operator">==</span> <span class="ruby-value">:keyword</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">match</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;goto&quot;</span>
          <span class="ruby-identifier">state</span> = <span class="ruby-value">:goto_label_expected</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">kind</span> <span class="ruby-operator">==</span> <span class="ruby-value">:keyword</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">match</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;local&quot;</span>
          <span class="ruby-identifier">state</span> = <span class="ruby-value">:local_var_expected</span>
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-identifier">kind</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\{/</span>) <span class="ruby-comment"># Opening table brace {</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">begin_group</span>(<span class="ruby-value">:map</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-value">:inline_delimiter</span> <span class="ruby-operator">:</span> <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">state</span>        = <span class="ruby-value">:map</span>
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\}/</span>) <span class="ruby-comment"># Closing table brace }</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">brace_depth</span> = <span class="ruby-value">0</span>
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:map</span>)
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-comment"># Mismatched brace</span>
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:error</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:inline_delimiter</span>)
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:map</span>)
          <span class="ruby-identifier">state</span> = <span class="ruby-value">:map</span>
        <span class="ruby-keyword">end</span>
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[&quot;']/</span>) <span class="ruby-comment"># String delimiters &quot; and '</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">begin_group</span>(<span class="ruby-value">:string</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">start_delim</span> = <span class="ruby-identifier">match</span>
        <span class="ruby-identifier">state</span>       = <span class="ruby-value">:string</span>
      
                        <span class="ruby-comment"># ↓Prefix                hex number ←|→ decimal number</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/-? (?:0x\h* \. \h+ (?:p[+\-]?\d+)? | \d*\.\d+ (?:e[+\-]?\d+)?)/</span><span class="ruby-identifier">x</span>) <span class="ruby-comment"># hexadecimal constants have no E power, decimal ones no P power</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:float</span>)
      
                        <span class="ruby-comment"># ↓Prefix         hex number ←|→ decimal number</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/-? (?:0x\h+ (?:p[+\-]?\d+)? | \d+ (?:e[+\-]?\d+)?)/</span><span class="ruby-identifier">x</span>) <span class="ruby-comment"># hexadecimal constants have no E power, decimal ones no P power</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:integer</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/[\+\-\*\/%^\#=~&lt;&gt;\(\)\[\]:;,] | \.(?!\d)/</span>) <span class="ruby-comment"># Operators</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>) <span class="ruby-comment"># Space</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      
      <span class="ruby-keyword">else</span> <span class="ruby-comment"># Invalid stuff. Note that Lua doesn’t accept multibyte chars outside of strings, hence these are also errors.</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
      <span class="ruby-keyword">end</span>
      
      <span class="ruby-comment"># It may be that we’re scanning a full-blown subexpression of a table</span>
      <span class="ruby-comment"># (tables can contain full expressions in parts).</span>
      <span class="ruby-comment"># If this is the case, return to :map scanning state.</span>
      <span class="ruby-identifier">state</span> = <span class="ruby-value">:map</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">state</span> <span class="ruby-operator">==</span> <span class="ruby-value">:initial</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">1</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:function_expected</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\(.*?\)/</span>) <span class="ruby-comment"># x = function() # &quot;Anonymous&quot; function without explicit name</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_] (?:[a-zA-Z0-9_\.] (?!\.\d))* [\.\:]/</span>) <span class="ruby-comment"># function tbl.subtbl.foo() | function tbl:foo() # Colon only allowed as last separator</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:ident</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]*/</span>) <span class="ruby-comment"># function foo()</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:function</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>) <span class="ruby-comment"># Between the `function' keyword and the ident may be any amount of whitespace</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:goto_label_expected</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]*/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:label</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>) <span class="ruby-comment"># Between the `goto' keyword and the label may be any amount of whitespace</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
      <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:local_var_expected</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/function/</span>) <span class="ruby-comment"># local function ...</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:keyword</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:function_expected</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]*/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:local_variable</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/,/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\=/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
        <span class="ruby-comment"># After encountering the equal sign, arbitrary expressions are</span>
        <span class="ruby-comment"># allowed again, so just return to the main state for further</span>
        <span class="ruby-comment"># parsing.</span>
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\n/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
      <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:long_comment</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/.*?(?=\]={#{num_equals}}\])/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:content</span>)
        
        <span class="ruby-identifier">delim</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/\]={#{num_equals}}\]/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">delim</span>, <span class="ruby-value">:delimiter</span>)
      <span class="ruby-keyword">else</span> <span class="ruby-comment"># No terminator found till EOF</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">rest</span>, <span class="ruby-value">:error</span>)
        <span class="ruby-identifier">terminate</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:comment</span>)
      <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:long_string</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/.*?(?=\]={#{num_equals}}\])/</span>) <span class="ruby-comment"># Long strings do not interpret any escape sequences</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:content</span>)
        
        <span class="ruby-identifier">delim</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/\]={#{num_equals}}\]/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">delim</span>, <span class="ruby-value">:delimiter</span>)
      <span class="ruby-keyword">else</span> <span class="ruby-comment"># No terminator found till EOF</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">rest</span>, <span class="ruby-value">:error</span>)
        <span class="ruby-identifier">terminate</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:string</span>)
      <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:string</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/[^\#{start_delim}\n]+/</span>) <span class="ruby-comment"># Everything except \ and the start delimiter character is string content (newlines are only allowed if preceeded by \ or \z)</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:content</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\(?:['&quot;abfnrtv\]|z\s*|x\h\h|\d{1,3}|\n)/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:char</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">start_delim</span>))
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:string</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\n/</span>) <span class="ruby-comment"># Lua forbids unescaped newlines in normal non-long strings</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-string">&quot;\\n\n&quot;</span>, <span class="ruby-value">:error</span>) <span class="ruby-comment"># Visually appealing error indicator--otherwise users may wonder whether the highlighter cannot highlight multine strings</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:string</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
      <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:map</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[,;]/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]* (?=\s*=)/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:key</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>), <span class="ruby-value">:space</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">check</span>(<span class="ruby-regexp">/\s+/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\=/</span>), <span class="ruby-value">:operator</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># Note this clause doesn’t advance the scan pointer, it’s a kind of</span>
        <span class="ruby-comment"># &quot;retry with other options&quot; (the :initial state then of course</span>
        <span class="ruby-comment"># advances the pointer).</span>
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">raise</span>
    <span class="ruby-keyword">end</span>
    
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:keep_state</span>]
    <span class="ruby-ivar">@state</span> = <span class="ruby-identifier">state</span>
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span> <span class="ruby-value">:string</span> <span class="ruby-keyword">if</span> [<span class="ruby-value">:string</span>].<span class="ruby-identifier">include?</span> <span class="ruby-identifier">state</span>
  <span class="ruby-identifier">brace_depth</span>.<span class="ruby-identifier">times</span> { <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span> <span class="ruby-value">:map</span> }
  
  <span class="ruby-identifier">encoder</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- scan_tokens-source -->
          
        </div>

        

        
      </div><!-- scan_tokens-method -->

    
      <div id="method-i-setup" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">setup</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><a href="Scanner.html">Scanner</a> initialization.</p>
          

          
          <div class="method-source-code" id="setup-source">
            <pre><span class="ruby-comment"># File lib/coderay/scanners/lua.rb, line 53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">setup</span>
  <span class="ruby-ivar">@state</span> = <span class="ruby-value">:initial</span>
  <span class="ruby-ivar">@brace_depth</span> = <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- setup-source -->
          
        </div>

        

        
      </div><!-- setup-method -->

    
    </section><!-- protected-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.2.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

